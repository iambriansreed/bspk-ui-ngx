/**
 * Generates metadata for component demos by parsing documentation JSON.
 *
 * $ npx tsx .scripts/generate-meta.ts --write
 */

import { execSync } from 'child_process';
import { toPascalCase } from './utils';
import fs from 'fs';
import path from 'path';
import { ComponentMeta, Meta, ComponentPhase } from '../projects/shared/src/types/meta';
import { COMPONENT_PHASES } from '../projects/shared/src/utils/phases';

const __dirname = path.dirname(new URL(import.meta.url).pathname);

execSync('npx @compodoc/compodoc -p tsconfig.doc.json -e json -d ./.tmp');

const documentationPath = path.join(__dirname, '../.tmp/documentation.json');

fs.writeFileSync(
    documentationPath.replace('.json', '.ts'),
    `
export const documentation: Documentation = ` + fs.readFileSync(documentationPath, 'utf-8'),
    'utf-8',
);

export const generatedMetaPath = 'projects/demo/src/meta.ts';

export async function generateMeta(dev?: boolean): Promise<Meta> {
    const documentation = await import('../.tmp/documentation.ts').then((m) => m.documentation);

    // find components that end with 'ComponentNameExample' and their base component 'ComponentName'

    const branch = execSync(`git branch --show-current`, { encoding: 'utf-8' }).trim();

    const commit = execSync('git rev-parse --short HEAD', { encoding: 'utf-8' }).trim();

    const version: string = JSON.parse(fs.readFileSync(path.join(__dirname, '../package.json'), 'utf-8')).version || '';

    type ComponentDirective = (typeof documentation.components)[number] | (typeof documentation.directives)[number];

    async function generateComponentMeta(): Promise<ComponentMeta[]> {
        const docComponents = documentation.components.filter((comp) => comp.name && comp.name.startsWith('UI'));

        const docDirectives = documentation.directives.filter((comp) => comp.name && comp.name.startsWith('UI'));

        const exampleComponents = [
            docComponents
                //
                .filter((comp) => comp.name?.endsWith('Example') && comp.name?.startsWith('UI')),
        ].flat();

        return [...docComponents, ...docDirectives]
            .flatMap((comp): ComponentMeta => {
                const exampleComp = exampleComponents.find(
                    (exComp: any) =>
                        exComp.name === `${comp.name}Example` ||
                        exComp.name === `${comp.name.replace(/Directive$/, '')}Example`,
                );

                const name = toPascalCase(comp.name.replace(/^UI/, '').replace(/Directive$/, ''));

                const slug = name.replace(/([a-z])([A-Z])/g, (_: any, a: any, b: string) => `${a}-${b}`).toLowerCase();

                const example = comp.rawdescription.match(/```html([\s\S]*?)```;/)?.[1]?.trim() || '';

                // remove code from rawdescription
                const description = comp.rawdescription.split('```html')[0].trim();

                const phase = (comp.sourceCode.match(/@phase\s+(\w+)/)?.[1] || 'Dev') as ComponentPhase;

                if (!COMPONENT_PHASES[phase]) {
                    throw new Error(`Invalid phase "${phase}" for component ${comp.name}`);
                }

                return {
                    css: '',
                    hasTouchTarget: false,
                    dependencies: [],
                    name,
                    className: comp.name,
                    slug,
                    file: comp.file,
                    // descriptionExample: comp.description,
                    description,
                    phase,
                    directive: comp.name.endsWith('Directive'),
                    exampleFile: exampleComp
                        ? {
                              name: exampleComp.name as string,
                              path: exampleComp.file as string,
                          }
                        : undefined,

                    associatedTypes: generateMetaAssociatedTypes(comp),
                };
            })
            .sort((a, b) => {
                if (a.name !== b.name) return a.name.localeCompare(b.name);
                // directives before non-directives
                return Number(b.directive) - Number(a.directive);
            })
            .filter((value, index, self) => {
                const prevName = index > 0 ? self[index - 1].name : null;
                return !prevName || prevName !== value.name;
            });
    }

    function generateMetaAssociatedTypes(comp: ComponentDirective): any[] {
        // Implementation for generating associated types metadata
        return [];
    }

    return { components: await generateComponentMeta(), version, hash: branch === 'main' ? commit : branch };
}

export async function writeMetaToFile(dev?: boolean): Promise<Meta> {
    const meta = await generateMeta(dev);
    const metaFileContent = `/**
 * This file is auto-generated by the ".scripts/generate-meta.ts" script.
 * Do not edit this file directly.
 */
    
import { Meta } from '@shared/types/meta';

export const META: Meta = ${JSON.stringify(meta, null, 4)};
`;
    fs.writeFileSync(generatedMetaPath, metaFileContent);

    return meta;
}

// if --write is provided, generate the routes once
if (process.argv.includes('--write')) {
    await writeMetaToFile();

    console.log(`\n\x1b[32mâœ… Generated component metadata at ${generatedMetaPath} ðŸ“„\x1b[0m\n`);
}
